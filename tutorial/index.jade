.step(data-title='How it Works')
  :markdown
    ## How It Works

    Let's go over the steps necessary to implement click-to-call in our application:

    ![Click-to-call Diagram](//s3-us-west-2.amazonaws.com/deved/clicktocall.png)

    1. A website visitor wants to connect to your organization.  She submits a web form with her phone number to receive a call connecting her to your sales or support team. 

    1. Your web application receives the form submission.  An HTTP request is initiated from your application to Twilio to initiate an outbound call. 

    1. Twilio receives the request and initiates a call to the user's phone number.

    1. User receives the call.

    1. After the call connects, Twilio asks our application for [TwiML instructions](/docs/api/twiml). Our TwiML instructs Twilio to connect the user to our sales or support teams.

    ## What We Will Learn

    This How-To demonstrates initializing a call using the [Twilio REST API][rest] and creating TwiML call logic using the [Say][say] and [Dial][dial] verbs.

    Sound like a plan? Let's get started!

    [rest]: /docs/api/rest/
    [dial]: /docs/api/twiml/dial
    [say]: /docs/api/twiml/say
.step(data-title="Application Overview", data-file='clicktocall/app.py')
  :markdown
    ## Our Flask Application

    In this example, we're using the [Flask framework](http://flask.pocoo.org) for Python. Flask is a popular, lightweight web framework that provides HTTP request routing, server-side HTML rendering, and an extensible stack to process incoming requests.

    To run this application locally, you can download it from the links above.  After extracting the app to a local directory, make sure to run `pip install -r requirements.txt` in that directory to install all of the application's dependencies from [the Cheese Shop](https://pypi.python.org/pypi).

    This file, `app.py`, creates our Flask application and starts an HTTP server.  Most of the server-side code for this example is located here. The HTML template containing the interface our users will use for click-to-call is in the `clicktocall/templates` directory.  Static assets such as images, stylesheets and JavaScript are located in `clicktocall/static`.

    We'll check that out in a moment, but first we need to configure our application with our Twilio account information.


.step(data-title='Application Config', data-file='clicktocall/local_settings.py', data-highlight='13-17')
  :markdown
    ## Application Configuration

    In this file, we pull in all the account configuration we need to run the application. Rather than storing these configuration values in a source file, you may want to store them as system environment variables. In this Python code, we're reading in values from these variables. On systems such as OSX or Linux, you can quickly create new environment variables with `export YOUR_VARIABLE=somevalue`.

    Our app will need your Twilio account credentials and a phone number to use for outbound calls. Your account credentials can be [found on your dashboard](/user/account) - let's briefly explain what these variables are:

    * `TWILIO_ACCOUNT_SID` : Your account SID - this is like your username for the Twilio API
    * `TWILIO_AUTH_TOKEN` : Your auth token - this is like your password for the Twilio API
    * `TWILIO_NUMBER` : a Twilio number [from your account](/user/account/phone-numbers/incoming)

    Okay, now that our app is configured, let's move on to the code. We'll begin by showing how we render the home page for this application.

.step(data-title='Import Dependencies', data-file='clicktocall/app.py', data-highlight='1-8')
  :markdown
    ## Import Dependencies

    We'll kick off our project by importing some of our dependencies.  First, we'll
    get a number features from the Flask framework that we are going to use: the
    `Flask` class to create our application, `render_template` to deliver our HTML
    to the user, `request` to process the information in POSTs we receive from our
    users interacting with our form and Twilio, and `url_for` to construct the URI
    we need to share with Twilio for our TwiML.

    Next, we'll import a couple helpful bits from the Twilio python module: `twiml`
    to help generate the instructions we give to Twilio for our calls and
    `TwilioRestClient` to initiate those calls with Twilio.
.step(data-title='How it Works', data-file='app.py')
  :markdown
    ## Flask Boilerplate

    First, we'll create a file in our project root called `app.py` to seperate the
    boilerplate to run our Flask app from the logic of our Click to Call
    implementation.  This includes importing the `app` object we create in
    `clicktocall/app.py` and then running it if the script is executed.

    For convenience sake for Heroku users, if the `PORT` environment variable
    exists, we'll run the app on the PORT the environment specified.  If not, we'll
    run on port 5000 and turn on debug mode for as we work on our project.
.step(data-title="Route: Home Page", data-file='clicktocall/app.py', data-highlight="15-19")
  :markdown
    ## Rendering the Home Page

    This route is pretty simple - for requests to the root URL of our web app, we will render a [Jinja2](http://jinja.pocoo.org/docs/dev/) template with the HTML, CSS, and JavaScript to drive our click-to-call page.


.step(data-title='Form Post URL', data-file='clicktocall/app.py', data-highlight="22-44")
  :markdown
    ## Form POST Url

    This route will respond to an AJAX request from the UI for our click-to-call web page, which we'll examine in a moment. Here, we use an authenticated Twilio REST API client to make an outbound phone call to the phone number that was submitted by the user. 

    For an outbound phone call, we need to specify a public URL for Twilio to request once the call has connected, so it knows what to do next. In a click to call application, these instructions could be as simple as "dial our sales number", or it could put a user into a full blown IVR system you've built.

    In this request, we assume that the domain that your app is running on is stored in the "host" header (probable in production), but you could change this to be anything. When Twilio dials out to the user, it will use the TwiML generated by the `/outbound` route, which we'll examine next.

.step(data-title='TwiML Response', data-file='clicktocall/app.py', data-highlight='47-61')
  :markdown
    ## Controller - TwiML Instructions

    Before Twilio will connect a call, it needs to know what to do once the call is made. Twilio will request these instructions from your web app as an XML document, using tags that we call [TwiML](/docs/api/twiml) to tell it what to do. 

    In this route, we are going to use the Twilio Python module to generate an XML document that looks like this, using the Twiml `Say` and `Dial` tags:

        <Response>
          <Say voice="alice">
            Thanks for calling [...]
          </Say>
          <!-- in a real app, you would dial your sales team or whomever -->
          <!--
          <Dial>+16515551111</Dial>
          -->
        </Response>

    That's most of the interesting bits on the back end - let's move to the front end code to see how we're collecting the phone number from the user.
.step(data-title='UI: Page Structure', data-file='clicktocall/templates/index.html', data-highlight="2-12")
  :markdown
    ## UI: Styles

    Here on our home page, we generate an HTML page that we present to a user so they can click a button to get connected with us. To make the page a little more friendly, we include styles from [Twitter Bootstrap](http://getbootstrap.com/). We also include styles for a third-party jQuery plugin that make it easier to collect and validate international phone numbers.
.step(data-title="UI: Form", data-file='clicktocall/templates/index.html', data-highlight="27-43")
  :markdown
    ## UI: Form Structure

    In the body of our HTML template, we generate a form with a single text field for the user to enter their phone number. We assign unique IDs to both the form and the phone number text field, as we will need both in the JavaScript we write to submit this form. Let's take a look at that code next.


.step(data-title='UI: Phone Input', data-file='clicktocall/static/js/app.js', data-highlight="4-8")
  :markdown
    ## UI: Smart Phone Number Field

    Our click to call page makes use of a [jQuery plugin](https://github.com/Bluefieldscom/intl-tel-input) to present a nice looking, auto-validating phone number input.  Here, we tell the plugin to decorate a text field with a given ID and tell it to validate numbers as the user types.

.step(data-title='UI: Submitting Form', data-file='clicktocall/static/js/app.js', data-highlight='10-32')
  :markdown
    ## UI: Submitting the Form
    This chunk of code overrides the default form submission behavior of the HTML page to asynchronously submit the form via Ajax.

    When the form is submitted, we listen for that event in JavaScript, and cancel the default behavior in the DOM (which is to submit the form and initiate a page turn).  Next, we create an Ajax request to our back end, passing along the phone number which was entered by the user.

    When the Ajax request completes, the server sends a brief JSON response with either a success message or an error.  In the success case, we display an alert indicating the call was connected successfully.

.step(data-title='Finish')
  :markdown
    ## All Done
    Congrats! You just learned how to build a working Click-to-Call solution. To improve upon this you could add two-factor authentication to your app, or create an interactive survey to follow-up with your customer.

    Thanks for checking out this tutorial! If you have any feedback to share with us, we'd love to hear it. Tweet [@twilio](http://twitter.com/twilio) to let us know what you think.
